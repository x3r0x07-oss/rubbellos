<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Rubbellos f√ºr dich ‚ù§Ô∏è</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  :root { color-scheme: light; }
  body {
    margin: 0;
    height: 100vh;
    background: linear-gradient(135deg, #ffb6c1, #ffe4e1);
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
  }
  #container {
    position: relative;
    width: 320px;
    height: 220px;
    border-radius: 18px;
    overflow: hidden;
    background: #fff;
    box-shadow: 0 10px 25px rgba(0,0,0,0.25);
  }
  #message {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 20px;
    box-sizing: border-box;
    pointer-events: none; /* damit die Canvas alle Pointer-Events bekommt */
  }
  #message h2 {
    margin: 0 0 10px;
    color: #e75480;
  }
  #message p {
    font-size: 20px;
    font-weight: bold;
  }
  canvas#scratch {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;  /* WICHTIG: CSS-Gr√∂√üe f√ºllt den Container */
    display: block;
  }
</style>
</head>
<body>

<div id="container">
  <div id="message">
    <h2>üíñ F√ºr meine wundervolle Frau üíñ</h2>
    <p>üéâ Gl√ºckwunsch!<br>Eine Fu√ümassage gewonnen üë£</p>
  </div>
  <canvas id="scratch"></canvas>
</div>

<script>
(function () {
  const canvas = document.getElementById("scratch");
  const ctx = canvas.getContext("2d", { willReadFrequently: false });

  let isDrawing = false;
  let scale = 1; // Verh√§ltnis von interner Canvas-Gr√∂√üe zu CSS-Gr√∂√üe

  function resizeCanvas() {
    // CSS-Gr√∂√üe
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;

    // Ger√§tepixel-Verh√§ltnis ber√ºcksichtigen (scharfe Darstellung auf HiDPI)
    const dpr = window.devicePixelRatio || 1;

    // Interne Zeichenfl√§che anpassen
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);

    // Zeichenkontext zur√ºcksetzen und skalieren
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);

    // Skalfaktor f√ºr Pointer-Koordinaten
    scale = dpr;

    drawCover(); // Deckschicht neu zeichnen
  }

  function drawCover() {
    // komplette Fl√§che f√ºllen (in CSS-Pixeln zeichnen, da Kontext skaliert ist)
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = "#d3d3d3";
    ctx.fillRect(0, 0, w, h);

    ctx.font = "22px Segoe UI, system-ui, -apple-system, sans-serif";
    ctx.fillStyle = "#555";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Hier freirubbeln ‚ú®", w / 2, h / 2);

    // Ab jetzt ‚Äûwegradieren‚Äú
    ctx.globalCompositeOperation = "destination-out";
  }

  function posFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    if (e.touches && e.touches[0]) {
      const t = e.touches[0];
      return {
        x: (t.clientX - rect.left),
        y: (t.clientY - rect.top)
      };
    } else {
      return {
        x: (e.clientX - rect.left),
        y: (e.clientY - rect.top)
      };
    }
  }

  function scratchAt(x, y) {
    // Radius in CSS-Pixeln (der Kontext ist bereits skaliert)
    const r = 20;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
  }

  // Pointer-Events (Maus)
  canvas.addEventListener("mousedown", (e) => {
    isDrawing = true;
    const p = posFromEvent(e);
    scratchAt(p.x, p.y);
  });
  window.addEventListener("mouseup", () => (isDrawing = false));
  canvas.addEventListener("mousemove", (e) => {
    if (!isDrawing) return;
    const p = posFromEvent(e);
    scratchAt(p.x, p.y);
  });

  // Touch-Events
  canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    isDrawing = true;
    const p = posFromEvent(e);
    scratchAt(p.x, p.y);
  }, { passive: false });

  window.addEventListener("touchend", () => (isDrawing = false));
  canvas.addEventListener("touchmove", (e) => {
    e.preventDefault();
    if (!isDrawing) return;
    const p = posFromEvent(e);
    scratchAt(p.x, p.y);
  }, { passive: false });

  // Initialisierung & Resize
  window.addEventListener("resize", resizeCanvas);
  // Warten, bis Layout steht (sicher bei GitHub Pages)
  window.requestAnimationFrame(resizeCanvas);
})();
</script>

</body>
</html>

